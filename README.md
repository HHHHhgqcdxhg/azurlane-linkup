# azurlane-linkup
做了个自动玩连连看的脚本.  
blog: [https://blog.purecucumber.club/azurlane-llk/](https://blog.purecucumber.club/azurlane-llk/)
## 图片整理
将原图整理成以下格式  

- 原图:
    ![](https://pic.ggemo.com/picgo/Screenshot_2019-03-01-19-24-27.png)
- 整理出:  


```python
[[  0.   0.   0.   0.   0.   0.   0.   0.   0.   0.   0.]
 [  0.  16.   2.   4.   1.   3.   1.   2.  17.   3.   0.]
 [  0.   8.   7.  14.   4.  10.  12.  18.   5.   5.   0.]
 [  0.   6.   6.   9.  15.   7.  11.   8.   9.  10.   0.]
 [  0.  11.  12.  13.  13.  14.  15.  16.  17.  18.   0.]
 [  0.   0.   0.   0.   0.   0.   0.   0.   0.   0.   0.]]
 #这个二维数组是抽象的连连看"地图",将原连连看相同的图片换成同样的数字,在在周围填充0表示通路
 ```
和
```python
[[1, 6], [1, 4], [1, 7], [1, 2], [1, 9], [1, 5], [2, 4], [1, 3], [2, 9], [2, 8], [3, 2], [3, 1], [3, 5], [2, 2], [3, 7], [2, 1], [3, 8], [3, 3], [3, 9], [2, 5], [4, 1], [3, 6], [4, 2], [2, 6], [4, 4], [4, 3], [4, 5], [2, 3], [4, 6], [3, 4], [4, 7], [1, 1], [4, 8], [1, 8], [4, 9], [2, 7]]
# 这个数组每一项表示一组坐标,并且第 2 * i 个元素代表的图片和第 2 * i + 1 个元素代表的图片相同  
```
## 求解
#### 算法
广度优先暴搜,搜索所有可以到达的图片块,判断目标是否在其中.  
代码在源码中的```findLineFetch```方法和```pointSearch```方法,注释还写的蛮详细的,这里不再解释.  
#### 实行点击: 
跟上次的[翻牌游戏脚本](https://blog.purecucumber.club/blhx-fanpai4-45)差不多
## 结果
7.80s视频: [av45062991](https://www.bilibili.com/video/av45062991/)  
7.80s留了视频,有一个7.27s的没录好...  
追求极致的话应该能跑进7秒内,说不定能跑进6秒内,我做不到一定是因为我太菜了
#### 时间浪费
- 截图耗时
    因为开局前截图会有数字遮挡,所以等数字消完,再进行截图.因为有一些IO操作,所以就很慢...
- 算法耗时
    嘛,我这个算法是广度优先暴搜,应该比较慢.
- 点击间隔不统一
    ↑这个形容不是很准确.好像,当两个有效的点被点击时,如果距离比较近,下次可以点击的时间间隔就比较短,反之亦然.只是推测,不太确定.因为试的时候,经常前面好多都没事,最后两三组点的时候出错,怀疑是排到最后的组一般距离比较远导致的结果.
